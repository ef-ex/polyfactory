#include <math.h>


float getTheta(float angle) {
    // get theta for street grid
    return  atan2( sin(radians(angle)), cos(radians(angle)) );
}


vector getMinor(float theta) {
    // get major vector for street grid
    return normalize( set(cos(theta), 0, sin(theta)) );
}


vector getMajor(float theta) {
    // get minor vector for street grid
    float angle = theta + PI/2;
    return normalize( set(cos(angle), 0, sin(angle)) );
}


vector getNewDir( vector prevDir, newDir; int vf, npt; float sampleRad; string direction){
    vector dirvec = set(0,0,0);
    int npts[] = nearpoints(vf, point(vf, "P", npt), sampleRad);

    foreach(int pt; npts){
        dirvec += point(vf, direction, pt)*point(vf, "weight", pt);
    }
    dirvec = normalize(dirvec);
    if (dot(prevDir, newDir)>=0){
        return dirvec;
    }
    else{
        return dirvec*-1;
    }
}

int drawStreet( int vf, steps; vector pos, currDir; float stepSize, sampleRad ; string dir){
    int pt, prim, npt;
    string type;
    vector prevDir, newDir;
    
    pt = addpoint(0, pos);
    prim = addprim(0, "polyline");
    addvertex(0, prim, pt);
    npt = nearpoint(vf, pos, sampleRad);
    
    for (int i=0; i<steps; i++){

        npt = nearpoint(vf, pos, sampleRad);
        newDir = getNewDir(currDir, point(vf, dir, npt), vf, npt, sampleRad, dir);
        pos = pos+newDir*stepSize;
        pt = addpoint(0, pos);
        addvertex(0, prim, pt);
        currDir = newDir;

    }
    return prim;
}
